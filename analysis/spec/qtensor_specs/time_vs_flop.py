# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/Time_vs_FLOP.ipynb (unless otherwise specified).

__all__ = ['ex', 'graph', 'circuit', 'tn', 'peo', 'sim_costs', 'sum_flops', 'step_flops', 'max_mem', 'SEED',
           'sim_profile', 'step_sim_time', 'plot_with_filter', 'get_log_flops_vs_matmul', 'cli', 'time_vs_flops_plot']

# Cell
import sys
import numpy as np
import matplotlib.pyplot as plt
import scipy

import qtensor as qt
from cartesian_explorer import Explorer

# Cell
import matplotlib as mpl
from cycler import cycler
mpl.rcParams['axes.prop_cycle'] = cycler(color=['#db503d', '#02C6E0'])

# Cell
ex = Explorer()

# Cell
@ex.provider
def graph(n, d, seed):
    return qt.toolbox.random_graph(nodes=n, degree=d, seed=seed)

@ex.provider
def circuit(graph, edge_idx, p):
    gamma, beta = [.1]*p, [.3]*p
    comp = qt.QtreeQAOAComposer(graph, gamma=gamma, beta=beta)
    comp.energy_expectation_lightcone(list(graph.edges())[edge_idx])
    return tuple(comp.circuit)

@ex.provider
def tn(circuit):
    return qt.optimisation.TensorNet.QtreeTensorNet.from_qtree_gates(circuit)

@ex.provider
def peo(tn, ordering_algo='greedy', tamaki_wait_time=15):
    if ordering_algo=='greedy':
        opt = qt.optimisation.Optimizer.DefaultOptimizer()
    elif 'tamaki' in ordering_algo:
        if '_' in ordering_algo:
            _, time_str = ordering_algo.split('_')
            tamaki_wait_time=int(time_str)
        opt = qt.optimisation.Optimizer.TamakiOptimizer(wait_time=tamaki_wait_time)
    peo, _ = opt.optimize(tn)
    return tuple(peo)

@ex.provider
def sim_costs(tn, peo):
    costs, mems = tn.simulation_cost(peo)
    return costs, mems

@ex.provider
def sum_flops(sim_costs):
    flops, mems = sim_costs
    return sum(flops)

# Cell
@ex.provider
def step_flops(sim_costs):
    flops, mems = sim_costs
    return tuple(flops)

@ex.provider
def max_mem(sim_costs):
    flops, mems = sim_costs
    return max(mems)

# Cell
SEED=107

# Cell
@ex.provider
def sim_profile(circuit, tn, backend='numpy'):
    if backend == 'numpy':
        backend = qt.PerfNumpyBackend(print=False)
    elif backend == 'mkl':
        backend = qt.ProcessingFrameworks.PerfBackend.from_backend(
            qt.ProcessingFrameworks.CMKLExtendedBackend, print=False)
    elif backend == 'debug_mkl':
        backend = qt.DebugFrameworks.DebugMKLBackend()
    sim = qt.QtreeSimulator(bucket_backend=backend)

    sim.simulate(circuit)
    data = backend._profile_results
    return tuple(tuple([tuple(x[0]), x[1]]) for x in data.values())

@ex.provider
def step_sim_time(sim_profile, tn):
    ignored_vars = tn.bra_vars+tn.ket_vars
    times = [x[1] for x in sim_profile]
    return tuple(times[len(ignored_vars):])

# Cell
def plot_with_filter(est_flat, times_flat):
    filt = (est_flat>5e4) #& (times_flat>1e-4)
    est_flat_filtered = est_flat[filt]
    times_flat_filtered = times_flat[filt]

    # Fit times
    log_fit_coef = np.polyfit(np.log(est_flat_filtered), np.log(times_flat_filtered), 1)
    fit_coef = np.polyfit(est_flat_filtered, times_flat_filtered, 1)
    def fixed_slope(x, shift):
        slope = 1.0
        return x*slope + shift
    popt, pcov = scipy.optimize.curve_fit(fixed_slope, np.log(est_flat_filtered), np.log(times_flat_filtered))
    print('Lin fit:', fit_coef)
    print('Log fit:', log_fit_coef)
    print('Slope-1 log fit:', popt)
    fit_fn = np.poly1d(log_fit_coef)
    fit_fn = fixed_slope

    # Plot scatter with filtered data
    plt.scatter(est_flat_filtered, times_flat_filtered, marker='x')
    min_x = np.log10(est_flat_filtered.min())
    max_x = np.log10(est_flat_filtered.max()) + .5
    xfit = 10**np.linspace(min_x, max_x, 100)
    plt.plot(xfit, np.exp(fit_fn(np.log(xfit), popt[0])), color='blue')
    plt.loglog()
    plt.xlabel('estimated FLOP')
    plt.ylabel('Runtime')
    plt.grid()
    return log_fit_coef, fit_coef

# Cell
import timeit
def get_log_flops_vs_matmul(log_fit_coef):
    FLOPS_logfit = np.exp(-log_fit_coef[1])

    N = 500
    matmul_flop = N**2*(N-1)
    x, y = np.random.randn(2, N, N)
    number = 100
    matmul_time = timeit.timeit(lambda: np.matmul(x,y)
                               , number=number)/number

    FLOPS_matmul = matmul_flop/matmul_time

    return FLOPS_logfit, FLOPS_matmul

# Cell
import click

@click.group()
def cli():
    pass

@click.argument('filename', nargs=-1)
@click.option('-B', '--backend', default='numpy')
@click.option('-M', '--max-memory', default=3e8)
@click.option('-s', '--seed', default=SEED)
@click.option('-O', '--ordering_algo', default='greedy'
              ,help=("One of (greedy, tamaki, tamaki_{wait_time})"
                     "'tamki_15' means heuristic solver running for 15 seconds per graph"
                    )
             )
@click.option('--min-memory', default=3e6)
def time_vs_flops_plot(filename=None, backend='numpy', seed=SEED,
                       max_memory=2e8, min_memory=1e6,
                       ordering_algo='greedy', tamaki_time=10
                      ):
    """
    Plots times and estimated FLOP for each step of several QAOA energy computation contractions.

    Currently using
        - random regular graphs with degree=3,4
        - p = 3
        - N = 1000

    """
    ds = [3, 4]
    p = 3
    N = 1000

    edges_to_try = 20
    estimators, maxmems = ex.map_variables(
        ('step_flops', 'max_mem'),
         d=ds,
         edge_idx=range(edges_to_try), n=[N], p=[p],
         seed=[seed],
         ordering_algo=[ordering_algo],
        )


    selector = ((min_memory < maxmems) & (maxmems < max_memory)).all(axis=0)
    edge_indices = np.arange(edges_to_try)[selector]
    print('Selected edges', edge_indices)
    print('Estimated memories', maxmems.T[selector].flatten())
    estimators = estimators.T[selector]

    times = ex.map_variable('step_sim_time', d=ds,
                            edge_idx=edge_indices, n=[N], p=[p]
                            ,seed=[seed]
                            ,backend=[backend]
                            ,ordering_algo=[ordering_algo]
                           )

    est_flat = np.concatenate(estimators.T.flatten())
    times_flat = np.concatenate(times.flatten())

    log_fit_coef, fit_coef = plot_with_filter(est_flat, times_flat)
    if filename:
        plt.savefig(filename[0])

    fit, matmul = get_log_flops_vs_matmul(log_fit_coef)

    print('===Results===')
    print(f'Total time: {times_flat.sum():.5}')
    print(f'Simulator fitted flops: {fit/1e9:.5} G')
    print(f'Matmul flops: {matmul/1e9:.5} G')
    print(f'Simulator optimality: {fit/matmul}')

cli.command()(time_vs_flops_plot)