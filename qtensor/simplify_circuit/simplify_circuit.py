# -*- coding: utf-8 -*-
"""
Created on Tue Oct 27 14:54:39 2020

@author: jonat
"""
from numpy import pi, argsort, sqrt, diff, array, random
import time
from qtensor.simplify_circuit.gates import zzphase, xphase, yphase, zphase, hadamard, ident, cnot, toffoli



def does_this_commute(op1,op2):
    '''
    op1,op2 - two operators to check if
    
    [op1,op2] = 0  : returns True
    [op1,op2]!= 0  : returns False
    '''
 
    
    
    '''  
    Two operators commute if they share simultanious eigenbases.
    
    This code checks commutation by checking the "name" if the eigenbasis
    on all of the sites that the gates act nontrivially. For the operators above
    there are only a few "names":
        X for gates generated by sigma_X
        Y for gates generated by sigma_Y
        Z for gates generated by sigma_Z
        X+Z for the Hadamard gate, which is a rotation by pi/2/sqrt(2)
    
    Note that this is not general!! For some gates, the eigenbasis is entangled
     and thus does not factorize like above. This is the case for the CNOT gate, for example.
     In this case, operators should "share an eigenbasis" across the two sites.
    '''
    simultanious_eigenbasis = True
    # Check the eigenbasis of the indices that both of the two gates act on
    for inds in set(op1.index).intersection(op2.index):
        simultanious_eigenbasis = simultanious_eigenbasis and (op1.eigenbasis[inds]==op2.eigenbasis[inds])
    return simultanious_eigenbasis

def does_this_simplify(op1,op2,return_ops = True):
    '''
    op1,op2 - two operators to check if the product of them can be represented
    by another simple gate (eg X phase times X phase is another X phase)
    
    if it cannot simplify return
      ( False, False )
    if it can simplify, return the simplified gates as
      ( identity,  op12 )     if the operators simplify to op12
      ( identity, identity )  if the operators cancel
    '''
    
    # 200nsec
    if type(op1)!=type(op2): # Two gates of different types don't simplify.
        return False,False
    # 40nsec
    if op1.index!=op2.index: # gates are on different sites
        return False,False
    
    if return_ops==False:
        return True,True
    
    
    # This could be sped up with inplace operations...
    # 1100nsec
    if abs(op1.angle+op2.angle)<1e-5: # Two gates cancel
        return ident(),ident()
    # 1200nsec
    return ident(),type(op1)(*op1.index,op1.angle + op2.angle) # DIRTY DIRTY CODE





def simplify_circuit(circuit_in):
    if not len(circuit_in): return []
    cirq = [*circuit_in]

    '''
    1. Find all pairs of gates which could simplify
    
    ......*---*....
    
    '''
    # scales as 100nsec * N^2. 3000 operators in 1 second.
    simplifications = []
    for i in range(len(cirq)-1):
        for j in range(i+1,len(cirq)):
            if does_this_simplify(cirq[i],cirq[j],return_ops=False)[0] is not False:
                simplifications.append((i,j))

    
    if simplifications == []:
        return cirq
    
    
    
    '''
    2. For each pair, starting with the ones closest together, check if they
        commute with all of the gates in between
    
    pictorially:    
    ......*---*....
    
    does [ * , - ] commute?
    
    '''
    
    # Sort pairs by distance from each other
    ToDoInds = argsort(diff(array(simplifications),1)[:,0])
    # I believe this scales as N^2 but very weakly. Scaling will be dominated by N.
    for ind in ToDoInds:
        
        # Don't do anything if some of the operators has already been simplified to the identity...
        if type(cirq[simplifications[ind][0]])==ident or type(cirq[simplifications[ind][1]])==ident:
            continue
        
        # For this operator pair, check if the gates in between commute
        commutes = True
        for ii in range(simplifications[ind][0] + 1,simplifications[ind][1]):
            commutes = commutes and does_this_commute(cirq[simplifications[ind][0]],cirq[ii])
        
        # If they do, replace them with their simplified versions
        if commutes == True:
            op1b,op2b = does_this_simplify(cirq[simplifications[ind][0]],cirq[simplifications[ind][1]])
            assert op1b!=False and op2b!=False
            
            cirq[simplifications[ind][0]] = op1b
            cirq[simplifications[ind][1]] = op2b
    
    
    # Remove identities from the circuit
    cirq_out = [q for q in cirq if type(q)!=ident]
    
    return cirq_out

if __name__=="__main__":
    
    circuit = []
    
    circuit.append(zphase(2,-.3))
    circuit.append(zzphase(1,2,0.2))
    circuit.append(zphase(2,0.1))
    circuit.append(xphase(0,0.1))
    circuit.append(zzphase(0,1,-0.3))
    circuit.append(xphase(0,-0.1))
    
    circuit.append(zzphase(0,2,pi/2))  # This would be like a ZZ operator acting on sites 0 and 2 (up to a phase)
    
    # Observe that this is the reverse of the circuit above. If this middle
    #  gate is commented out the entire circuit will cancel out.
    circuit.append(xphase(0,0.1))
    circuit.append(zzphase(0,1,0.3))
    circuit.append(xphase(0,-0.1))
    
    circuit.append(xphase(1,0.35))   # two gates in the middle which cancel themselves
    circuit.append(zphase(2,-0.1))
    circuit.append(xphase(1,-0.35))
    
    circuit.append(zzphase(1,2,-0.2))
    circuit.append(zphase(2,.3))
    

    
    simplified_circuit = simplify_circuit(circuit)
    for cc in simplified_circuit:
        print(cc)
        
    
    '''
    Benchmark with a random circuit
    '''
    Nqubits = 100
    Ngates = 4000
    circuit = []
    for ctr in range(Ngates):
        rr = random.permutation(Nqubits)
        th = random.rand()
        gate_choice = [xphase(rr[0],th)]
        gate_choice = [zzphase(rr[0],rr[1],th)]
        circuit.append(random.choice(gate_choice))
    
    t1 = time.time()
    circuit2 = simplify_circuit(circuit)
    t2 = time.time()
    print('{:0.0f} random gates over {:0.0f} qubits simplified in {:0.3f} seconds'.format(Ngates,Nqubits,t2-t1))
    print('Circuit was simplified to {:0.0f} gates'.format(len(circuit2)))
    
    '''
    Benchmark with p=1 QAOA
    '''
    import networkx as nx
    G = nx.random_regular_graph(3,500)
    circuitF = []
    circuitR = []
    
    for p in range(2):
        beta = random.rand()
        gamma = random.rand()
        for edge in G.edges:
            circuitF.append(zzphase(edge[0],edge[1],gamma))
            circuitR.append(zzphase(edge[0],edge[1],-gamma))
        for ii in G.nodes:
            circuitF.append(xphase(ii,beta))
            circuitR.append(xphase(ii,-beta))
    
    circuitF.append(zzphase(edge[0],edge[1],pi/2)) # This is 1j * Z0Z1
    
    t3 = time.time()
    circuit2 = simplify_circuit(circuitF + circuitR[-1::-1])
    t4 = time.time()
    print('{:0.0f} QAOA gates over {:0.0f} qubits simplified in {:0.3f} seconds'.format(len(circuitF)+len(circuitR),len(G.nodes),t4-t3))
    print('Circuit was simplified to {:0.0f} gates'.format(len(circuit2)))
